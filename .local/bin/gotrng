#!/usr/bin/env bash
#
# Script Name: Got Random?
# Script URL: https://git.sr.ht/~jamesponddotco/dotfiles
# Description: Feed the kernel entropy pool with data from an OneRNG device.
# Version: 0.1.0
# Author: James Pond
# Author URL: https://jamespond.co/
# License: European Union Public License 1.2 or later
# License URI: https://joinup.ec.europa.eu/collection/eupl/eupl-text-11-12
#

# Use bash's "unofficial strict mode".
set -o errexit -o nounset -o errtrace -o pipefail
IFS=$'\n\t'

# Force all output to use the simplest locale.
LC_ALL='C'
readonly LC_ALL

# Save the name of the script inside a readonly variable.
whoami="${0##*/}"
readonly whoami

# Colours make the output easier on the eyes, but we respect NO_COLOR in case
# you do not agree.
if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
  c_red='\033[0;31m'
  c_blue='\033[0;34m'
  c_bold='\033[1m'
  c_reset='\033[0m'
  readonly c_red
  readonly c_blue
  readonly c_bold
  readonly c_reset
fi

display_usage() {

  # Display usage information when necessary.
  echo -e "${c_blue:-}${c_bold:-}USAGE:${c_reset:-}"
  echo -e "${c_bold:-}$whoami${c_reset:-} [-f|--feeder </onerng/device/path/>] \
[-s|--stop </onerng/device/path/>] [-fw|--verify-firmware \
</onerng/device/path/>] [-h|--help]"

}

run_checks() {

  # Ensures that the script is executed with sudo or root.
  if [[ "${EUID}" -ne 0 ]]; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Permission denied. Use \
root or sudo."
    exit 13
  fi

  # Ensures the user provided a path to the OneRNG device.
  if [[ -z "${2:-}" ]]; then
    display_usage
    exit 22
  fi

  # Save the device path given by the user.
  onerng_path="/dev/${2:-}"
  readonly onerng_path

  # Make sure the device the user is trying to use is actually an OneRNG.
  if ! udevadm info "${onerng_path}" | grep --quiet 'OneRNG'; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Invalid device. Please \
connect an OneRNG and try again."
    exit 1
  fi

  # Create a lock file if this is our first time running the script, but exit
  # if we are already doing it.
  if [[ -f '/run/lock/gotrng.lock' ]]; then
    if [[ "${1:-}" =~ ^(-f$|--feeder$) ]]; then
      echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Operation already in \
progress."
      exit 114
    fi
  else
    touch '/run/lock/gotrng.lock'
  fi

}

start_onerng() {

  # Change the TTY device to raw mode, the device itself to whitening mode, and
  # turn on the data feed.
  chown 'root:root' "${onerng_path}"
  chmod 600 "${onerng_path}"
  stty --file "${onerng_path}" raw -echo
  echo 'cmd0' > "${onerng_path}"
  echo 'cmdO' > "${onerng_path}"

}

stop_onerng() {

  # Turn noise gathering and the device off, and then flush the entropy pool.
  echo 'cmdo' > "${onerng_path}"
  echo 'cmd4' > "${onerng_path}"
  echo 'cmdw' > "${onerng_path}"

}

stop_feeder() {

  # Remove the lock file, which should be enough to stop the feeder loop.
  rm --force '/run/lock/gotrng.lock'

}

verify_onerng_firmware() {

  # Change the TTY device to raw mode, disable model control signals, and
  # enable RTS handshaking.
  stty --file "${onerng_path}" raw -echo clocal -crtscts

  # Create a temporary file for data to be written to.
  local onerng_temp_file
  onerng_temp_file="$(mktemp --tmpdir --quiet 'gotrng-XXXXXXXXXX')"
  readonly onerng_temp_file

  # Read data from the OneRNG device to the temporary file, but save the PID so
  # we can kill it later if necessary.
  dd if="${onerng_path}" iflag=fullblock of="${onerng_temp_file}" bs=4 &
  local dd_pid
  dd_pid="$!"
  readonly dd_pid
  sleep 0.02

  # Start OneRNG and extract an image of the CPU's code memory which we can use
  # to verify the device's firmware.
  echo 'cmdO' > "${onerng_path}"
  echo 'cmdX' > "${onerng_path}"
  
  # Wait for everything above to complete, but kill the dd process if it is
  # still running.
  sleep 3.5
  if ps --pid "${dd_pid}" > '/dev/null' 2>&1; then
    kill -SIGTERM "${dd_pid}"
  fi
  stop_onerng

  # Run onerng_verify.py against the dumped image to verify its signature.
  set +e
  onerng_verify.py "${onerng_temp_file}"
  firmware_status="$?"
  set -e

  # Remove the temporary file, as we do not need it anymore.
  rm --force "${onerng_temp_file}"

  # Exit if the onerng_verify.py test failed, since this may be a bad or
  # compromised device.
  if [[ "${firmware_status}" -eq 1 ]]; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Device is broken or has \
been compromised."
    exit 1
  fi

}

feeding_method_feeder() {

  # Create an infinite loop to feed entropy into the kernel random subsystem in
  # five seconds intervals, but check for the existing of a lock file each
  # time, so we can stop the feeder by removing the file.
  while true; do
    if [[ -f '/run/lock/gotrng.lock' ]]; then
      dd if="${onerng_path}" of='/dev/random' bs=128 count=200 \
        > '/dev/null' 2>&1
      sleep 5
    else
      exit 0
    fi
  done

}

# Call our functions.
case "${1:-}" in
  -f|--feeder)
    run_checks "$@"
    stop_onerng
    verify_onerng_firmware
    start_onerng
    feeding_method_feeder
    ;;
  -s|--stop)
    run_checks "$@"
    stop_feeder
    stop_onerng
    ;;
  -fw|--verify-firmware)
    run_checks "$@"
    stop_onerng
    verify_onerng_firmware
    ;;
  *)
    display_usage
    exit 22
esac

# All was well.
exit 0
