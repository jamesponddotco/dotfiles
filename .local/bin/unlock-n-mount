#!/usr/bin/env bash
#
# Script Name: Unlock N' Mount
# Script URL: https://git.sr.ht/~jamesponddotco/dotfiles
# Description: Unlock and mount an external drive encrypted with LUKS.
# Version: 1.0.0
# Author: James Pond
# Author URL: https://jamespond.co/
# License: European Union Public License 1.2 or later
# License URI: https://joinup.ec.europa.eu/collection/eupl/eupl-text-11-12
#

# Use bash's "unofficial strict mode".
set -o errexit -o nounset -o errtrace -o pipefail
IFS=$'\n\t'

# Force all output to use the simplest locale.
LC_ALL='C'
readonly LC_ALL

# Save the name of the script inside a readonly variable.
whoami="${0##*/}"
readonly whoami

# Color variables to make our output a little easier on the eyes. Respect
# NO_COLOR, in case the user does not want any.
if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
  c_red='\033[0;31m'
  c_blue='\033[0;34m'
  c_bold='\033[1m'
  c_reset='\033[0m'
  readonly c_red
  readonly c_blue
  readonly c_bold
  readonly c_reset
fi

display_usage() {

  # Display usage information when necessary.
  echo -e "${c_blue:-}${c_bold:-}USAGE:${c_reset:-}"
  echo -e "${c_bold:-}$whoami${c_reset:-} [-m|--mount </path/to/drive/>] \
[-u|--unmount </path/to/drive/>] [-rw|--read-write] [-h|--help]"

}

run_checks() {

  # Ensures that the script is not executed with sudo or root.
  if [[ "$EUID" == 0 ]]; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Permission denied. Do \
not use root or sudo."
    exit 13
  fi

  # Save the drive path given by the user and the device UUID.
  drive_path="${2:-}" drive_path="${drive_path,,}"
  drive_name="${drive_path##*/}"
  drive_uuid="$(find '/dev/disk/by-uuid' -lname "*/$drive_name" -printf '%f')"
  readonly drive_path
  readonly drive_name
  readonly drive_uuid

  # Ensures the user provided a path to the drive.
  if [[ -z "$drive_path" ]]; then
    display_usage
    exit 5
  fi

  # Ensure that the drive actually exists.
  if [[ -z "$drive_uuid" ]]; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} No such device."
    exit 19
  fi

  # Make sure that the user has the device password in the password store.
  if ! [[ "${1:-}" =~ ^(-u$|--unmount$) ]]; then
    if ! [[ -f "$HOME/.password-store/drives/$drive_uuid.gpg" ]]; then
      echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Drive password missing."
      exit 13
    fi
  fi

  # Make sure that the user has the random password salt saved in 1Password.
  if ! [[ "${1:-}" =~ ^(-u$|--unmount$) ]]; then
    yubikey_password_salt="$(1p get item "$drive_uuid" --fields password \
      2> '/dev/null')"
    readonly yubikey_password_salt
    if [[ -z "${yubikey_password_salt:-}" ]]; then
      echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} YubiKey password salt \
missing from 1Password."
      exit 13
    fi
  fi

  # Check to see if the drive has not been mounted already, but only if we are
  # not trying to unmount it.
  if ! [[ "${1:-}" =~ ^(-u$|--unmount$) ]]; then
    if lsblk --noheadings --output 'UUID' "/dev/mapper/luks-$drive_uuid" \
      2>/dev/null; then
      echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Drive already mounted."
      exit 114
    fi
  fi

  # Check to see if the user forgot to connect their YubiKey.
  if ! [[ "${1:-}" =~ ^(-u$|--unmount$) ]]; then
    if ! lsusb | grep --quiet 'Yubikey'; then
      echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} YubiKey required. Please \
connect it and try again."
      exit 126
    fi
  fi

}

flush_thumbnail_cache() {

  # Remove the thumbnails generated by Nautilus in case the content of the
  # device is in any way sensitive.
  rm --recursive --force "$HOME/.cache/thumbnails/fail/"
  rm --recursive --force "$HOME/.cache/thumbnails/large/"
  rm --recursive --force "$HOME/.cache/thumbnails/normal/"

}

construct_luks_password() {

  # Get the key file for LUKS from the password store and save it.
  local drive_password
  drive_password="$(pass show drives/"$drive_uuid" 2>&1 \
    | tr --delete '\n')"
  readonly drive_password

  # Send 64 bytes of the drive password as a challenge to the YubiKey and save
  # the response inside a local and readonly variable.
  local yubikey_challenge_response
  yubikey_challenge_response="$(ykchalresp -2 "${drive_password:0:64}")"
  readonly yubikey_challenge_response

  # Use Argon2id to hash the YubiKey challenge response with the random salt we
  # got from 1Password in the test phase. The Argon2 settings are based on my
  # own hardware,usage, and patience, so you may need to change them,
  # especially the memory part.
  local yubikey_password
  yubikey_password="$(echo -n "$yubikey_challenge_response" \
    | argon2 "$yubikey_password_salt" -id -t 40 -m 20 -p 8 -e)"
  readonly yubikey_password

  # Construct the actual password we use to unlock the LUKS device.
  luks_password="$yubikey_password\$$drive_password"
  readonly luks_password

}

mount_drive() {

  # Keep mount options inside a variable so we can modify them via an argument.
  # Default to making the device read-only.
  if [[ "${3:-}" =~ ^(-rw$|--read-write$) ]]; then
    local drive_mount_options
    drive_mount_options='rw,noexec,nosuid,nodev,noatime,nodiratime'
  else
    local drive_mount_options
    drive_mount_options='ro,noexec,nosuid,nodev,noatime,nodiratime'
  fi

  # Construct the LUKS password by using a random password stored in the
  # password store and the response from YubiKey to a challenge.
  construct_luks_password

  # Start by unlocking the device, since it is encrypted with LUKS. By using
  # udisks we can avoid the sudo requirement from cryptsetup.
  udisksctl unlock --block-device "$drive_path" \
    --key-file <(echo -n "$luks_password") >/dev/null 2>&1

  # Mount the device with extra security options.
  udisksctl mount --block-device "/dev/mapper/luks-$drive_uuid" \
    --options "$drive_mount_options" >/dev/null 2>&1

}

unmount_drive() {

  # Unmount, lock, and power off the drive.
  udisksctl unmount --block-device "/dev/mapper/luks-$drive_uuid"
  udisksctl lock --block-device "$drive_path"
  udisksctl power-off --block-device "$drive_path"

}

# Call our functions.
case "${1:-}" in
  -m|--mount)
    run_checks "$@"
    mount_drive "$@"
    ;;
  -u|--unmount)
    run_checks "$@"
    unmount_drive "$@"
    flush_thumbnail_cache
    ;;
  -h|--help)
    display_usage
    ;;
  *)
    display_usage
    exit 22
esac

# All was well.
exit 0
