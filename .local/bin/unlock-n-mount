#!/usr/bin/env bash
#
# Script Name: Unlock N' Mount
# Script URL: https://git.sr.ht/~jamesponddotco/dotfiles
# Description: Unlock and mount an external drive encrypted with LUKS.
# Version: 0.1.0
# Author: James Pond
# Author URL: https://jamespond.co/
# License: European Union Public License 1.2 or later
# License URI: https://joinup.ec.europa.eu/collection/eupl/eupl-text-11-12
#

# Use bash's "unofficial strict mode".
set -o errexit -o nounset -o errtrace -o pipefail
IFS=$'\n\t'

# Force all output to use the simplest locale.
LC_ALL='C'
readonly LC_ALL

# Save the name of the script inside a readonly variable.
whoami="${0##*/}"
readonly whoami

# Color variables to make our output a little easier on the eyes. Respect
# NO_COLOR, in case the user does not want any.
if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
  c_red='\033[0;31m'
  c_blue='\033[0;34m'
  c_bold='\033[1m'
  c_reset='\033[0m'
  readonly c_red
  readonly c_blue
  readonly c_bold
  readonly c_reset
fi

display_usage() {

  # Display usage information when necessary.
  echo -e "${c_blue:-}${c_bold:-}USAGE:${c_reset:-}"
  echo -e "${c_bold:-}$whoami${c_reset:-} [-m|--mount </path/to/drive/>] \
[-u|--unmount </path/to/drive/>] [-rw|--read-write] [-h|--help]"

}

run_checks() {

  # Ensures that the script is not executed with sudo or root.
  if [[ "$EUID" == 0 ]]; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Permission denied. Do \
not use root or sudo."
    exit 13
  fi

  # Save the drive path given by the user and the device UUID.
  drive_path="${2:-}" drive_path="${drive_path,,}"
  drive_name="${drive_path##*/}"
  drive_uuid="$(find '/dev/disk/by-uuid' -lname "*/$drive_name" -printf '%f')"
  readonly drive_path
  readonly drive_name
  readonly drive_uuid

  # Ensures the user provided a path to the drive.
  if [[ -z "$drive_path" ]]; then
    display_usage
    exit 5
  fi

  # Ensure that the drive actually exists.
  if [[ -z "$drive_uuid" ]]; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} No such device."
    exit 19
  fi

  # Make sure that the user has the device password in the password store.
  if ! [[ -f "$HOME/.password-store/drives/$drive_uuid.gpg" ]]; then
    echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Drive password missing."
    exit 13
  fi

  # Check to see if the drive has not been mounted already, but only if we are
  # not trying to unmount it.
  if ! [[ "${1:-}" =~ ^(-u$|--unmount$) ]]; then
    if lsblk --noheadings --output 'UUID' "/dev/mapper/luks-$drive_uuid" \
      2>/dev/null; then
      echo -e "${c_red:-}${c_bold:-}[ERROR]${c_reset:-} Drive already mounted."
      exit 114
    fi
  fi

}

flush_thumbnail_cache() {

  # Remove the thumbnails generated by Nautilus in case the content of the
  # device is in any way sensitive.
  rm --recursive --force "$HOME/.cache/thumbnails/fail/"
  rm --recursive --force "$HOME/.cache/thumbnails/large/"
  rm --recursive --force "$HOME/.cache/thumbnails/normal/"

}

mount_drive() {

  # Keep mount options inside a variable so we can modify them via an argument.
  # Default to making the device read-only.
  if [[ "${3:-}" =~ ^(-rw$|--read-write$) ]]; then
    local drive_mount_options
    drive_mount_options='rw,noexec,nosuid,nodev,noatime,nodiratime'
  else
    local drive_mount_options
    drive_mount_options='ro,noexec,nosuid,nodev,noatime,nodiratime'
  fi

  # Get the key file for LUKS from the password store and save it.
  local drive_password
  drive_password="$(pass show drives/"$drive_uuid" 2>&1 \
    | tr --delete '\n')"

  # Start by unlocking the device, since it is encrypted with LUKS. By using
  # udisks we can avoid the sudo requirement from cryptsetup.
  udisksctl unlock --block-device "$drive_path" \
    --key-file <(echo -n "$drive_password") >/dev/null 2>&1

  # Mount the device with extra security options.
  udisksctl mount --block-device "/dev/mapper/luks-$drive_uuid" \
    --options "$drive_mount_options" >/dev/null 2>&1

}

unmount_drive() {

  # Unmount, lock, and power off the drive.
  udisksctl unmount --block-device "/dev/mapper/luks-$drive_uuid"
  udisksctl lock --block-device "$drive_path"
  udisksctl power-off --block-device "$drive_path"

}

# Call our functions.
case "${1:-}" in
  -m|--mount)
    run_checks "$@"
    mount_drive "$@"
    ;;
  -u|--unmount)
    run_checks "$@"
    unmount_drive "$@"
    flush_thumbnail_cache
    ;;
  -h|--help)
    display_usage
    ;;
  *)
    display_usage
    exit 22
esac

# All was well.
exit 0
